#!/usr/bin/env python3
"""
combine_notebooks_2.py

Improved notebook combiner with CLI options.

Features:
- Recursively finds .ipynb files under a base directory (default: script folder)
- Skips .ipynb_checkpoints and the output file itself
- Optionally accepts glob pattern to limit notebooks
- Preserves existing cell metadata.id when present; otherwise generates a uuid
- Ensures metadata.language is set for each cell
- Uses nbformat.normalize to reduce warnings about missing ids when possible

Usage examples:
    python combine_notebooks_2.py
    python combine_notebooks_2.py --base-dir "C:/path/to/workspace" --output All.ipynb
    python combine_notebooks_2.py --pattern "*/03-*.ipynb" --output Week3.ipynb
"""
from __future__ import annotations

import argparse
import glob
import os
import sys
import uuid
from typing import List, Optional

try:
    import nbformat
    from nbformat import v4
except Exception:  # pragma: no cover - user will install via requirements.txt
    print('This script requires the `nbformat` package. Install with: pip install -r requirements.txt')
    raise


def ensure_cell_metadata(cell: dict) -> dict:
    if not isinstance(cell.get('metadata'), dict):
        cell['metadata'] = {}

    # Ensure language metadata exists
    if 'language' not in cell['metadata']:
        if cell.get('cell_type') == 'code':
            cell['metadata']['language'] = 'python'
        else:
            cell['metadata']['language'] = 'markdown'

    # Preserve id if present, otherwise create one
    if not cell['metadata'].get('id'):
        cell['metadata']['id'] = uuid.uuid4().hex

    return cell


def find_notebooks(base_dir: str, pattern: str = '**/*.ipynb') -> List[str]:
    glob_pattern = os.path.join(base_dir, pattern)
    files = sorted(glob.glob(glob_pattern, recursive=True))
    # filter checkpoints
    files = [p for p in files if '.ipynb_checkpoints' not in p]
    return files


def combine_notebooks(
    base_dir: str,
    notebook_paths: List[str],
    output_path: str,
) -> Optional[str]:
    combined = v4.new_notebook()

    header_md = [
        '# Combined Notebook',
        f'Generated by combine_notebooks_2.py',
        '',
        f'Base directory: ``{base_dir}``',
        '',
        'Included notebooks:'
    ]

    for p in notebook_paths:
        header_md.append(f'- {os.path.relpath(p, base_dir)}')

    combined.cells.append(v4.new_markdown_cell('\n'.join(header_md)))

    total_cells = 0
    included = 0
    for nb_path in notebook_paths:
        # skip the output if it is inside the same tree
        if os.path.abspath(nb_path) == os.path.abspath(output_path):
            continue

        try:
            with open(nb_path, 'r', encoding='utf-8') as f:
                nb = nbformat.read(f, as_version=4)
        except Exception as e:
            print(f'Warning: failed to read {nb_path}: {e}', file=sys.stderr)
            continue

        # normalize to reduce missing id warnings when possible
        try:
            nb = nbformat.normalize(nb)
        except Exception:
            # normalize may not be available on very old nbformat versions; ignore
            pass

        # insert a notebook header
        header = v4.new_markdown_cell(f"## From: {os.path.relpath(nb_path, base_dir)}")
        header['metadata']['language'] = 'markdown'
        header['metadata']['id'] = uuid.uuid4().hex
        combined.cells.append(header)

        for cell in nb.cells:
            cell = ensure_cell_metadata(cell)
            combined.cells.append(cell)
            total_cells += 1

        included += 1

    try:
        with open(output_path, 'w', encoding='utf-8') as f:
            nbformat.write(combined, f)
        print(f'Wrote combined notebook to: {output_path}')
        print(f'Included {included} notebooks and {total_cells} cells.')
        return output_path
    except Exception as e:
        print(f'Failed to write combined notebook: {e}', file=sys.stderr)
        return None


def parse_args(argv: Optional[List[str]] = None) -> argparse.Namespace:
    p = argparse.ArgumentParser(description='Combine Jupyter notebooks into one notebook')
    p.add_argument('--base-dir', '-b', default=os.path.abspath(os.path.dirname(__file__)),
                   help='Base directory to search for notebooks (default: script folder)')
    p.add_argument('--pattern', '-p', default='**/*.ipynb', help='Glob pattern to find notebooks (recursive)')
    p.add_argument('--output', '-o', default='Combined_Notebook_2.ipynb', help='Output notebook filename')
    p.add_argument('--quiet', '-q', action='store_true', help='Suppress informational printing')
    return p.parse_args(argv)


def main(argv: Optional[List[str]] = None) -> int:
    args = parse_args(argv)
    base_dir = os.path.abspath(args.base_dir)
    output_path = os.path.join(base_dir, args.output)

    all_notebooks = find_notebooks(base_dir, args.pattern)
    # remove output if it matches pattern
    all_notebooks = [p for p in all_notebooks if os.path.abspath(p) != os.path.abspath(output_path)]

    if not all_notebooks:
        if not args.quiet:
            print('No notebooks found matching pattern under', base_dir)
        return 1

    if not args.quiet:
        print(f'Found {len(all_notebooks)} notebooks; combining to {output_path}...')

    res = combine_notebooks(base_dir, all_notebooks, output_path)
    return 0 if res else 2


if __name__ == '__main__':
    raise SystemExit(main())

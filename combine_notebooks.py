#!/usr/bin/env python3
"""
combine_notebooks.py

Scan the workspace for all .ipynb files (recursively), and combine their cells into
one notebook saved as Combined_Notebook.ipynb in the same folder as this script.

This script will:
- skip notebooks inside .ipynb_checkpoints folders
- skip the output combined notebook itself if present
- preserve existing cell metadata.id when present; otherwise generate a uuid
- ensure each cell has metadata.language set ('python' for code, 'markdown' for markdown)

Usage:
    python combine_notebooks.py

"""
import nbformat
import glob
import os
import uuid
from nbformat import v4


def ensure_cell_metadata(cell):
    # Ensure metadata exists
    if not isinstance(cell.get('metadata'), dict):
        cell['metadata'] = {}

    # Ensure language metadata
    if 'language' not in cell['metadata']:
        if cell.get('cell_type') == 'code':
            cell['metadata']['language'] = 'python'
        else:
            cell['metadata']['language'] = 'markdown'

    # Ensure metadata.id exists (preserve if present)
    if 'id' not in cell['metadata'] or not cell['metadata'].get('id'):
        # Use full uuid4 hex to be unique
        cell['metadata']['id'] = uuid.uuid4().hex

    return cell


def combine_notebooks(base_dir, output_name='Combined_Notebook.ipynb'):
    pattern = os.path.join(base_dir, '**', '*.ipynb')
    all_files = sorted(glob.glob(pattern, recursive=True))

    # Filter out checkpoints and the output file itself
    notebook_files = [p for p in all_files if 
                      '.ipynb_checkpoints' not in p and 
                      os.path.basename(p) != output_name]

    if not notebook_files:
        print('No notebooks found to combine under', base_dir)
        return None

    combined = v4.new_notebook()
    intro_lines = [
        '# Combined Notebook',
        f'This notebook was generated by combine_notebooks.py and includes cells from {len(notebook_files)} notebooks found under ``{base_dir}``.',
        '',
        'Notebooks included (in this order):',
    ]
    for p in notebook_files:
        rel = os.path.relpath(p, base_dir)
        intro_lines.append(f'- {rel}')

    combined.cells.append(v4.new_markdown_cell('\n'.join(intro_lines)))

    total_cells = 0
    for nb_path in notebook_files:
        try:
            with open(nb_path, 'r', encoding='utf-8') as f:
                nb = nbformat.read(f, as_version=4)
        except Exception as e:
            print('Failed to read', nb_path, 'skipping:', e)
            continue

        header = v4.new_markdown_cell(f"## From: {os.path.relpath(nb_path, base_dir)}")
        # ensure header has language metadata
        header['metadata']['language'] = 'markdown'
        header['metadata']['id'] = uuid.uuid4().hex
        combined.cells.append(header)

        for cell in nb.cells:
            # normalize and ensure required metadata
            cell = ensure_cell_metadata(cell)
            combined.cells.append(cell)
            total_cells += 1

    out_path = os.path.join(base_dir, output_name)
    try:
        with open(out_path, 'w', encoding='utf-8') as f:
            nbformat.write(combined, f)
        print(f'Wrote combined notebook to: {out_path}')
        print(f'Included {len(notebook_files)} notebooks and {total_cells} cells.')
        return out_path
    except Exception as e:
        print('Failed to write combined notebook:', e)
        return None


if __name__ == '__main__':
    base = os.path.abspath(os.path.dirname(__file__))
    combine_notebooks(base)
